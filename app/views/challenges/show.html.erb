
<% content_for :instructions do %>
    <!-- Contenido de las instrucciones del reto -->
    <div>
        <h1 class="text-3xl mb-8"> <%= @challenge.title %> </h1>
        <p class="my-4 text-sm"> <%= @challenge.intro %> </p>
        <p class="my-4 text-sm"> <%= @challenge.premise %> </p>
        <p class="my-4 text-sm"> <%= @challenge.tasks %> </p>
        <p class="my-4 text-sm font-medium"> <%= @challenge.notes %> </p>
    </div>
<% end %>

<% content_for :blockly do %>
    <!-- Contenido del editor -->
    <div id=editor_"<%= dom_id @challenge %>" class="flex flex-col">
        <div id="blocklyDiv"
            class="h-full w-full"
            style="height: 50vh; width: 40vw;">
            <a id="play-button"
                class="bg-blue-500 text-white rounded-full p-4 shadow-md absolute bottom-4 right-4">
                <svg class="h-6 w-6 rotate-90" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
                </svg>
            </a>
        </div>
        <div class="flex flex-col" style="height: 50vh; align-items: stretch;">
          <pre id="code-container" class="bg-white p-8 text-sm"  style="height: 50%; font-family: monospace;"><code id="generated-code" class="javascript language-javascript"></code></pre>
          <div class="p-8 text-red bg-black" style="color: red; overflow-y: auto; height: 50%;" id="debug-console"></div>
        </div>
        
    </div>
<% end %>

<% content_for :game do %>
    <!-- Contenido del juego -->
    <div id="editor_<%= dom_id @challenge %>" style="height: 100%;">
        <div id="gameDiv"
            class="text-white"
            style="height: 100%; overflow: hidden; display: flex; justify-content: center; background-image: url('/assets/background_space.png')">
            <canvas
                id="gameCanvas"
                width="480" height="960">
            </canvas>
        </div>
    </div>

    <div 
        class="flex justify-center items-center h-screen" 
        id="congratz" 
        style="
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        ">
        <div class="bg-white p-8 rounded-lg shadow-lg text-center">
            <div class="text-2xl font-semibold mb-4">Â¡Felicidades, has ganado!</div>
            <div class="text-4xl mb-6">ðŸŽ‰</div>
            <p>Gracias por jugar.</p>

            <ul id="positions">
            </ul>
        </div>
    </div>

    <%= render "toolbox" %>

    <script>

        

        var score = 1000;
        
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        var mapData = <%= raw @map.data() %>;

        const tileSize = 16;

        const resources = {};  
        var initialX = 0;
        var initialY = 0;

        const imagePaths = [
            '<%= raw @map.map_url %>'
            //'/assets/map2.png'
            // Agrega mÃ¡s rutas de imÃ¡genes aquÃ­ si es necesario
        ];

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        document.getElementById('play-button').addEventListener('click', async () => {
            await play();
        });

        function loadResources(callback) {
            let loadedCount = 0;

            imagePaths.forEach((path) => {
                const image = new Image();
                image.src = path;
                image.onload = () => {
                    resources[path] = image;
                    loadedCount++;

                    if (loadedCount === imagePaths.length) {
                        callback();
                    }
                };
            });
        }

        function init() {
            loadResources(() => {
                imagePaths.forEach((path) => {
                    drawImage(resources[path]);
                });
                
                drawBoxesAtRandomPositions();
                drawPlayerAtInitialPosition();
            });
        }

        function reDraw() {
            // Dibuja el mapa de nuevo
            init();
        }

        function drawPlayerAtInitialPosition() {
            // Dibuja al jugador en la posiciÃ³n inicial usando los datos de mapData (Objeto Player)
            const imagePlayer = new Image();
            imagePlayer.src = '/assets/astronaut.png';

            const x = mapData.objects[0].x + mapData.objects[0].width/4 ;
            const y = mapData.objects[0].y + mapData.objects[0].height/2;
            const width = mapData.objects[0].width;
            const height = mapData.objects[0].height;

            if (initialX == 0 && initialY == 0) {
                initialX = x;
                initialY = y;
            }

            imagePlayer.onload = () => {
                context.drawImage(imagePlayer, x, y, width, height);
            };

        }

        function drawBoxesAtRandomPositions() {
            // Chequear si hay boxes creados 
            if (mapData["boxes"].length == 0) {
                // Crear boxes

                // Dibuja las cajas en posiciones aleatorias en ubicaciones disponibles marcadas por Ground
                const randomInt = (max, min) => Math.round(Math.random() * (max - min)) + min;
                ground_map = mapData["ground"];
                n_boxes = randomInt(5, 10);
                boxes = [];
                for (let i = 0; i < n_boxes; i++) {
                    let x = randomInt(0, 6);
                    let y = randomInt(0, 11);
                    if (ground_map[y][x] != 0) {
                        const imageBox = new Image();
                        imageBox.src = '/assets/box.png';
                        x = x * 64 + 20;
                        y = y * 80;
                        const width = 64;
                        const height = 64;
                        imageBox.onload = () => {
                            context.drawImage(imageBox, x, y, width, height);
                        };
                        let randomValue = Math.random();
                        let randomContent = randomValue < 0.5 ? "food" : "poison";
                        boxes.push({
                            "height": 64,
                            "id": 3,
                            "name": "Box",
                            "width": 64,
                            "content": randomContent, // random between feed and poison
                            "x": x,
                            "y": y
                        });
                    }
                }
                // Guardar Boxes
                mapData["boxes"] = boxes;
             } else {
                // Dibujar boxes
                boxes = mapData["boxes"];
                boxes.forEach((box) => {
                    const imageBox = new Image();
                    imageBox.src = '/assets/box.png';
                    const x = box.x;
                    const y = box.y;
                    const width = box.width;
                    const height = box.height;
                    imageBox.onload = () => {
                        context.drawImage(imageBox, x, y, width, height);
                    };
                });
            }

        }

        function isBoxAtPlayerPosition() {
            box = mapData["boxes"].find(box => box.x > mapData.objects[0].x && box.x < mapData.objects[0].x + 64 && box.y > mapData.objects[0].y && box.y < mapData.objects[0].y + 64);
            if (box) {
                return true;
            } else {
                return false;
            }
        }

        // FunciÃ³n para dibujar una imagen
        function drawImage(image) {
            context.drawImage(image, 0, 0, 483, 966);
        }

        checkCollisions = () => {
            // Revisa si el jugador colisiona con algÃºn objeto del mapa
            console.log("checkCollisions");
            
            if (mapData.collitions[posY][posX] != 0) {
                console.log("colision");
            }
        }
        evaluateCodeQuality = (code) => {
          const eslint = new window.ESLint();
          const results = eslint.lintText(code);

          return results;
        }
        calcCodeScore = () => {
            // Calcula una metrica calidad del cÃ³digo
            let code = document.getElementById('generated-code').innerText;
            let codeLength = code.length;
            let codeQualityData = evaluateCodeQuality(code);
            let codeQualityScore = 1000 - codeLength * 10;
            codeQualityScore -= codeQualityData[0].errorCount * 50;
            codeQualityScore -= codeQualityData[0].warningCount * 10;
            return codeQualityScore;
        }

        checkIfWin = () => {
            // Revisa si el jugador ha ganado usando la posicion del jugador y la posicion del objeto Goal
            console.log("checkIfWin");
            if (posX() == Math.round(mapData.objects[1].x / 64) && posY() == Math.round(mapData.objects[1].y / 64)) {

                let username = prompt("Â¿Cual es tu nombre?");

                db.collection("scores/<%= @challenge.code %>/today").add({
                    "username": username,
                    "score": score
                }).then((docRef) => {
                    console.log("Document created with id: " + docRef.id)
                }).catch((error)=>{
                    console.log("Error: " + error)
                });

                db.collection("scores/<%= @challenge.code %>/today")
                    .orderBy("score", "desc") // Ordenar por el campo "score" en orden descendente
                    .limit(10) // Obtener solo los 10 primeros documentos
                    .onSnapshot((querySnapshot) => {
                    let li_str = "";
                    querySnapshot.forEach((doc) => {
                        let task = doc.data()
                        console.log(doc.data());
                        li_str += "<li>"
                        li_str += task.username + " - ";
                        li_str += task.score + "</li>";
                    })
                    
                    document.getElementById("positions").innerHTML = li_str;
                })

                

                console.log("win");
                document.getElementById("congratz").style.display = 'flex';
            }

            
        }

        var posX = () => { return Math.round(mapData.objects[0].x / 64)} ;
        var posY = () => { return Math.round((mapData.objects[0].y) / 64) -1} ;

        const moveAstronaut = {
            // Mueve al astronauta
            left: async () => {
                // mover lentamente hasta alcanzar 64 pixeles
                if (mapData.collitions[posY()][posX()-1] == 0) {
                    for (let i = 0; i < 64; i++) {
                        mapData.objects[0].x -= 1;
                        await sleep(10);
                        reDraw();
                    }
                    checkIfWin();
                } else {
                  throw "Error ... al intentar mover el astronauta con parametro 'left' se encontrÃ³ un obstaculo"
                }
                
            },
            right: async () => {
                if (mapData.collitions[posY()][posX()+1] == 0) {
                    for (let i = 0; i < 64; i++) {
                        mapData.objects[0].x += 1;
                        await sleep(10);
                        reDraw();
                        
                    }
                    checkIfWin();
                } else {
                  throw "Error ... al intentar mover el astronauta con parametro 'right' se encontrÃ³ un obstaculo"
                }
            },
            up: async () => {
              if (mapData.collitions[posY()-1][posX()] == 0) {
                for (let i = 0; i < 80; i++) {
                  if (mapData.objects[0].y >= 10) {
                      mapData.objects[0].y -= 1;
                      await sleep(10);
                      console.log(mapData.objects[0].y)
                      reDraw();
                    } else {
                      throw "Error ... se intentÃ³ mover el astronauta fuera del mapa"
                      break;
                    } 
                  } 
                  checkIfWin();
              } else {
                // raise error
                throw "Error ... al intentar mover el astronauta con parametro 'up' se encontrÃ³ un obstaculo"
              }
            
                
            },
            down: async () => {
                if (mapData.collitions[posY()+1][posX()] == 0) {
                    for (let i = 0; i < 80; i++) {
                        mapData.objects[0].y += 1;
                        await sleep(10);
                        reDraw();
                    }
                    checkIfWin();
                } else {
                  throw "Error ... al intentar mover el astronauta con parametro 'down' se encontrÃ³ un obstaculo"
                }
                // mover lentamente hasta alcanzar 64 pixeles
                console.log("down");
            },
        }

        async function move(direction) {
            // Mueve al astronauta en la direcciÃ³n indicada
            try {
              await moveAstronaut[direction]();
            } catch (error) {
              score -= 10;
              console.log("no se puede mover");
              const debugConsole = document.getElementById('debug-console');
              // Append a new node to the debug console
              const newNode = document.createElement('p');
              newNode.innerHTML = error;
              debugConsole.appendChild(newNode);
            }
            
            
        }

        function open_box() {
            // Abre la caja en la que se encuentra el jugador
            box = mapData["boxes"].find(box => box.x > mapData.objects[0].x && box.x < mapData.objects[0].x + 64 && box.y > mapData.objects[0].y && box.y < mapData.objects[0].y + 64);
            console.log(mapData["boxes"])
            if (box) {
                box_content = box["content"];
                // Eliminar box 
                return box_content
            } else {
              score -= 10;
              const debugConsole = document.getElementById('debug-console');
              // Append a new node to the debug console
              const newNode = document.createElement('p');
              newNode.innerHTML = "Error ... no se puede abrir la caja porque no hay ninguna en la posiciÃ³n actual";
              debugConsole.appendChild(newNode);
              throw "Error ... no se puede abrir la caja porque no hay ninguna en la posiciÃ³n actual"
            }
        }

        

        async function eat() {
            const debugConsole = document.getElementById('debug-console');
            // Come el contenido de la caja en la que se encuentra el jugador
            box = mapData["boxes"].find(box => box.x > mapData.objects[0].x && box.x < mapData.objects[0].x + 64 && box.y > mapData.objects[0].y && box.y < mapData.objects[0].y + 64);
            box_content = box["content"];
            // eliminar box
            mapData["boxes"] = mapData["boxes"].filter(box => box.x != mapData.objects[0].x && box.y != mapData.objects[0].y);
            // Dibujar
            reDraw();
            if (box_content == "food") {
                score += 100;
                // Aumentar puntos
                const newNode = document.createElement('p');
                newNode.className = "text-green-500";
                newNode.innerHTML = "Wow ... el astronauta encontrÃ³ comida, era lo que necesitaba";
                debugConsole.appendChild(newNode);
            } else {
                score -= 100;
                const newNode = document.createElement('p');
                newNode.innerHTML = "Error ... oh no ... el astronauta comiÃ³ veneno";
                debugConsole.appendChild(newNode);
                throw "Error ... oh no ... el astronauta comiÃ³ veneno";
            }
        }

        init();

      </script>

        <script>

            function beautifyCode() {
                const code = document.getElementById('generated-code').innerText;
                const beautifiedCode = js_beautify(code, {
                    indent_size: 2, // Puedes ajustar la cantidad de indentaciÃ³n
                    space_in_empty_paren: true,
                    preserve_newlines: true,
                });
                document.getElementById('generated-code').innerText = beautifiedCode;
            }

            function myUpdateFunction(event) {
                var code = Blockly.JavaScript.workspaceToCode(workspace);
                document.getElementById('generated-code').innerText = code;
                
                beautifyCode(); 
            }

            workspace.addChangeListener(myUpdateFunction);

            function play() {
                // clean debug console
                const debugConsole = document.getElementById('debug-console');
                debugConsole.innerHTML = "";
                mapData.objects[0].x = initialX;
                mapData.objects[0].y = initialY;
                code = (document.getElementById('generated-code').innerText);
                full_code = "async function play_game() {" + code + "}; play_game();";
                console.log(full_code);
                eval(full_code);
            }
        </script>

<% end %>

